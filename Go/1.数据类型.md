# 数据类型

## Go语言将数据类型分为四类

### 基础类型、复合类型、引用类型、接口类型

#### 1 基础类型 —— 数字、字符串、布尔型

（1）数字 ——  整数，有符号类型的整数 和 无符号类型的整数

  1. 有符号类型的整数：int8、int16、int32、int64  
    【大小：$-2^{n-1}$ 到 $2^{n-1}-1$，例如 int8: -128到127】
  2. 无符号类型的整数： uint8、uint16、uint32、uint64
    【大小：0 到 $2^n-1$，例如 uint8: 0 - 255】

（2）数字 —— 浮点数，float32、float64

（3）复数 —— 两种精度的复数类型：complex64、complex128

  【内建的 real 和 imag 函数分别返回复数的实部和虚部】

（4）字符串

（5）布尔型

#### 2 复合类型 —— 数组、slice、map、结构体

 【是通过组合简单类型，来表达更加复杂的数据结构】

  数组和结构体 是固定内存大小的数据结构，slice和map 是动态的数据结构(它们将根据需要动态增长)

（1）数组

  数组是一个由固定长度的特定类型元素组成的序列，长度是固定的

  ```go
    a := [2] int {1, 2}
    b := […] int {1, 2}
    c := [2] int {1, 3}
    d := [3] int {1, 2, 3}  

    fmt.Println(a == b, a == c, b == c) // "true false false"
    fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
  ```

（2）slice
  slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能

  1. 一个slice由三个部分构成：指针、长度(len)和容量(cap)
     1. 长度对应slice中元素的数目，长度不能超过容量
     2. 容量一般是从slice的开始位置到底层数据的结尾位置
  2. 多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠
  
  ```go
    // 创建一个数组
    months := [...] string {1: "January", /* ... */, 12: "December"}
    Q2 := months[4:7]  // 创建一个切片
    summer := months[6:9]     // 又扩展一个切片
    fmt.Println(summer[:20])  // panic: out of range
    var z = make([] int,  10,  20);  // int类型，len = 10,  cap = 20 

    // append
    var x []int
    x = append(x, 1)
    x = append(x, 2, 3)
    x = append(x, 4, 5, 6)
    x = append(x, x...) // append the slice x
    fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"

    // push v
    stack = append(stack, v) // push v

    // top of stack (stack的顶部位置对应slice的最后一个元素)
    top := stack[len(stack)-1]

    // pop (通过收缩stack可以弹出栈顶的元素)
    stack = stack[:len(stack)-1]

    // remove:
    // 要删除slice中间的某个元素并保存原有的元素顺序
    // 可以通过内置的copy函数将后面的子slice向前依次移动一位完成
    func remove(slice []int, int) []int {
      copy(slice(i:), slice(i + 1:))
      return slice(: len(slice) - 1)
    }
    func main() {
      s := []int {5, 6, 7, 8, 9}
      fmt.Println(remove(s, 2)) // "[5 6 8 9]"
    }

    // 如果删除元素后不用保持原来顺序的话
    // 我们可以简单的用最后一个元素覆盖被删除的元素
    func remove(slice []int, int) []int {
      slice[i] = slice[len(slice) - 1]
      return slice(: len(slice) - 1)
    }
    func main() {
      s := []int {5, 6, 7, 8, 9}
      fmt.Println(remove(s, 2)) // "[5 6 9 8]"
    }


  ```

（3）map

- 通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value
- map中所有的key都有相同的类型，所有的value也有着相同的类型.但是key和value之间可以是不同的数据类型

  ```go
    // 通过 make 创建 map
    ages := make(map[string] int) // 从字符串到整数的映射
    // 也可以用map字面值的语法创建map，同时还可以指定一些最初的key/value
    ages := map[string] int{
      "alice": 31,
      "charlie": 34
    }

    // len
    fmt.Println(len(ages)) // 2

    // 取值
    if age, ok := ages["bob"]; !ok { 
      /* "bob" is not a key in this map; age == 0. */
     }


    // delete
    delete(map, "alice")

    // 遍历 (Map的迭代顺序是不确定的,遍历的顺序是随机的,每一次遍历的顺序都不相同)
    for name, age := range ages {
      fmt.Printf("%s\t%d\n", name, age)
    }

    // map类型的零值是nil，也就是没有引用任何哈希表
    var ages map[string]int
    fmt.Println(ages == nil)    // "true"
    fmt.Println(len(ages) == 0) // "true"
  ```
  
（4）结构体

  ```go
    type Point struct{ 
      X, Y int
    }
    p := Point{1, 2}

    type Employee struct {
      ID            int
      Name,Address  string  // 相邻的成员类型如果相同的话可以被合并到一行
      DoB           time.Time
      Position      string
      Salary        int
      ManagerId     int
    }

    var dilbert Employee
    // 可以直接对每个成员赋值
    dilbert.Salary -= 5000
    // 或者是对成员取地址，然后通过指针访问
    position := &dilbert.Position
    *position = "Senior" + *posotion

  ```

（5）JSON

  ```go
  type Movie struct {
    Title  string
    Year   int  `json:"released"` // 这是一个Tag,转JSON时用released代替Year
    Color  bool `json:"color,omitempty"` // Tag,转JSON时省略空值
    Actors []string
  }

  var movies = []Movie{
      {
        Title: "Casablanca",
        Year: 1942,
        Color: false,
        Actors: []string{"Humphrey Bogart", "Ingrid Bergman"}
      },
      {
        Title: "Cool Hand Luke",
        Year: 1967,
        Color: true,
        Actors: []string{"Paul Newman"}
      },
      {
        Title: "Bullitt",
        Year: 1968,
        Color: true,
        Actors: []string{"Steve McQueen", "Jacqueline Bisset"}
      },
  }
  ```

  这样的数据结构特别适合JSON格式，并且在两者之间相互转换也很容易。
  编组通过调用 json.Marshal 函数完成：

  ```go
    data, err := json.Marshal(movies)
    if err != nil {
      log.Fatalf("JSON marshaling failed: %s", err)
    }
    fmt.Printf("%s\n", data)
  ```

  Marshal函数返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进；我们将它折行以便于显示：

  ```text
  [{"Title":"Casablanca","released":1942,"Actors":["Humphrey Bogart","Ingr
  id Bergman"]},{"Title":"Cool Hand Luke","released":1967,"color":true,"Ac
  tors":["Paul Newman"]},{"Title":"Bullitt","released":1968,"color":true,"
  Actors":["Steve McQueen","Jacqueline Bisset"]}]
  ```

  这种紧凑的表示形式虽然包含了全部的信息，但是很难阅读。为了生成便于阅读的格式，另一个json.MarshalIndent函数将产生整齐缩进的输出.该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：

  ```go
  data, err := json.MarshalIndent(movies, "", "    ")
  if err != nil {
    log.Fatalf("JSON marshaling failed: %s", err)
  }
  fmt.Printf("%s\n", data)
  ```

  上面的代码将产生这样的输出（在最后一个成员或元素后面并没有逗号分隔符）：

  ```JSON
  [
    {
        "Title": "Casablanca",
        "released": 1942,
        "Actors": [
          "Humphrey Bogart",
          "Ingrid Bergman"
        ]
    },
    {
        "Title": "Cool Hand Luke",
        "released": 1967,
        "color": true,
        "Actors": [
          "Paul Newman"
        ]
    },
    {
        "Title": "Bullitt",
        "released": 1968,
        "color": true,
        "Actors": [
          "Steve McQueen",
          "Jacqueline Bisset"
        ]
    }
  ]
  ```

  在编码时，默认使用Go语言结构体的成员名字作为JSON的对象。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。

  编码的逆操作是解码，通过 `json.Unmarshal` 函数完成.
  下面的代码将JSON格式的电影数据解码为一个结构体slice，结构体中只有Title成员。通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。当Unmarshal函数调用返回，slice将被只含有Title信息的值填充，其它JSON成员将被忽略。

  ```go
  var title []struct {Title string}
  if err := json.Unmarshal(data, &titles); err != nil {
    log.Fatalf("JSON unmarshaling failed: %s", err)
  }
  fmt.Println(titles) // "[{Casablanca} {Cool Hand Luke} {Bullitt}]"
  ```

#### 3 引用类型 —— 指针、切片、字典、函数、通道 【都是对程序中一个变量或状态的间接引用】

#### 4 接口类型
